name: VNC Data Static Timeout
on:
  workflow_dispatch:
    inputs:
      base64_config:
        description: 'Base64 encoded JSON configuration'
        required: true
        type: string

env:
  DISPLAY: :1
  VNC_PORT: 5901
  NOVNC_PORT: 6080

jobs:
  process:
    runs-on: ubuntu-latest
    timeout-minutes: 60
    
    steps:
      - name: Checkout
        uses: actions/checkout@v4
      
      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.12'
      
      - name: Fetch and Parse Config
        id: config
        run: |
          # Decode base64 config (without echoing it)
          CONFIG=$(echo "${{ inputs.base64_config }}" | base64 -d)
          
          # Parse VNC, Cloudflare, and Webshare values (lowercase keys)
          VNC_ENABLED=$(echo "$CONFIG" | jq -r '.vnc_enabled // "false"')
          CLOUDFLARE_ENABLED=$(echo "$CONFIG" | jq -r '.cloudflare_enabled // "false"')
          WEBSHARE_ENABLED=$(echo "$CONFIG" | jq -r '.webshare_enabled // "false"')
          echo "vnc_enabled=$VNC_ENABLED" >> $GITHUB_OUTPUT
          echo "cloudflare_enabled=$CLOUDFLARE_ENABLED" >> $GITHUB_OUTPUT
          echo "webshare_enabled=$WEBSHARE_ENABLED" >> $GITHUB_OUTPUT
          
          # Parse user_id and workspace_id with defaults
          USER_ID=$(echo "$CONFIG" | jq -r '.user_id // "69c3090b-464d-4de3-9358-ceca1c9e2aa8"')
          WORKSPACE_ID=$(echo "$CONFIG" | jq -r '.workspace_id // "ceae1caa-1538-4859-8e1a-24a8b4904d5f"')
          echo "user_id=$USER_ID" >> $GITHUB_OUTPUT
          echo "workspace_id=$WORKSPACE_ID" >> $GITHUB_OUTPUT
          
          # Parse VNC password if VNC is enabled
          if [ "$VNC_ENABLED" = "true" ]; then
            VNC_PASSWORD=$(echo "$CONFIG" | jq -r '.vnc_password // ""')
            echo "vnc_password=$VNC_PASSWORD" >> $GITHUB_OUTPUT
          fi
          
          # Parse Cloudflare-related values if Cloudflare is enabled
          if [ "$CLOUDFLARE_ENABLED" = "true" ]; then
            CLOUDFLARE_API_TOKEN=$(echo "$CONFIG" | jq -r '.cloudflare_api_token // ""')
            CLOUDFLARE_ACCOUNT_ID=$(echo "$CONFIG" | jq -r '.cloudflare_account_id // ""')
            CLOUDFLARE_ZONE_ID=$(echo "$CONFIG" | jq -r '.cloudflare_zone_id // ""')
            HOSTNAME=$(echo "$CONFIG" | jq -r '.hostname // ""')
            # Extract browser_profile_id from hostname (UUID prefix before first dot)
            # e.g. "a6b83dc3-1881-4285-957f-3c49c7b162ad.articleinnovator.com" -> "a6b83dc3-1881-4285-957f-3c49c7b162ad"
            BROWSER_PROFILE_ID=$(echo "$HOSTNAME" | cut -d'.' -f1)
            CLOUDFLARE_TUNNEL_CREDENTIAL_ID=$(echo "$CONFIG" | jq -r '.cloudflare_tunnel_credential_id // ""')

            echo "cloudflare_api_token=$CLOUDFLARE_API_TOKEN" >> $GITHUB_OUTPUT
            echo "cloudflare_account_id=$CLOUDFLARE_ACCOUNT_ID" >> $GITHUB_OUTPUT
            echo "cloudflare_zone_id=$CLOUDFLARE_ZONE_ID" >> $GITHUB_OUTPUT
            echo "hostname=$HOSTNAME" >> $GITHUB_OUTPUT
            echo "browser_profile_id=$BROWSER_PROFILE_ID" >> $GITHUB_OUTPUT
            echo "cloudflare_tunnel_credential_id=$CLOUDFLARE_TUNNEL_CREDENTIAL_ID" >> $GITHUB_OUTPUT

            echo "‚úÖ Cloudflare Config Loaded"
            echo "  Hostname: $HOSTNAME"
            echo "  Browser Profile ID: $BROWSER_PROFILE_ID"
          fi
          
          # Parse Wasabi S3
          #credentials for browser profile persistence
          WASABI_ACCESS_KEY=$(echo "$CONFIG" | jq -r '.wasabi_access_key // ""')
          WASABI_SECRET_KEY=$(echo "$CONFIG" | jq -r '.wasabi_secret_key // ""')
          WASABI_BUCKET=$(echo "$CONFIG" | jq -r '.wasabi_bucket // ""')
          WASABI_ENDPOINT=$(echo "$CONFIG" | jq -r '.wasabi_endpoint // "https://s3.wasabisys.com"')
          WASABI_REGION=$(echo "$CONFIG" | jq -r '.wasabi_region // "us-east-1"')
          echo "wasabi_access_key=$WASABI_ACCESS_KEY" >> $GITHUB_OUTPUT
          echo "wasabi_secret_key=$WASABI_SECRET_KEY" >> $GITHUB_OUTPUT
          echo "wasabi_bucket=$WASABI_BUCKET" >> $GITHUB_OUTPUT
          echo "wasabi_endpoint=$WASABI_ENDPOINT" >> $GITHUB_OUTPUT
          echo "wasabi_region=$WASABI_REGION" >> $GITHUB_OUTPUT

          if [ -n "$WASABI_ACCESS_KEY" ] && [ "$WASABI_ACCESS_KEY" != "" ]; then
            echo "‚úÖ Wasabi Config Loaded (Bucket: $WASABI_BUCKET)"
          fi

          # Parse Webshare-related values if Webshare is enabled
          if [ "$WEBSHARE_ENABLED" = "true" ]; then
            WEBSHARE_API_TOKEN=$(echo "$CONFIG" | jq -r '.webshare_api_token // ""')
            echo "webshare_api_token=$WEBSHARE_API_TOKEN" >> $GITHUB_OUTPUT
            
            echo "‚úÖ Webshare Config Loaded"
          fi
          
          echo "‚úÖ Config Loaded:"
          echo "  VNC: $VNC_ENABLED"
          echo "  Cloudflare: $CLOUDFLARE_ENABLED"
          echo "  Webshare: $WEBSHARE_ENABLED"
          echo "  User ID: $USER_ID"
          echo "  Workspace ID: $WORKSPACE_ID"
      
      - name: Register IP with Webshare
        if: steps.config.outputs.webshare_enabled == 'true'
        id: webshare
        run: |
          echo "Registering IP with Webshare..."
          
          # Get current public IP
          PUBLIC_IP=$(curl -s 'https://api.ipify.org?format=json' | jq -r '.ip')
          echo "Public IP: $PUBLIC_IP"
          
          # Register IP with Webshare
          RESPONSE=$(curl -s "https://proxy.webshare.io/api/v2/proxy/ipauthorization/" \
            -X POST \
            -d "{\"ip_address\": \"$PUBLIC_IP\"}" \
            -H "Content-Type: application/json" \
            -H "Authorization: Token ${{ steps.config.outputs.webshare_api_token }}")
          
          # Extract authorization ID
          AUTH_ID=$(echo "$RESPONSE" | jq -r '.id // empty')
          
          if [ -n "$AUTH_ID" ]; then
            echo "webshare_auth_id=$AUTH_ID" >> $GITHUB_OUTPUT
            echo "‚úÖ IP registered with Webshare (Auth ID: $AUTH_ID)"
          else
            echo "‚ö†Ô∏è Failed to register IP with Webshare"
            echo "$RESPONSE" | jq '.'
          fi
      
      - name: Install Desktop Environment
        if: steps.config.outputs.vnc_enabled == 'true'
        run: |
          echo "Installing XFCE desktop environment..."
          sudo apt-get update
          sudo DEBIAN_FRONTEND=noninteractive apt-get install -y \
            xfce4 \
            xfce4-goodies \
            xfce4-terminal \
            firefox \
            dbus-x11 \
            dbus-user-session \
            x11-utils \
            x11-apps \
            x11-common \
            x11-session-utils \
            x11-xserver-utils \
            xfonts-base \
            xfonts-100dpi \
            xfonts-75dpi \
            xfonts-cyrillic \
            xubuntu-icon-theme \
            xubuntu-wallpapers \
            gnome-icon-theme

      - name: Install Google Chrome
        if: steps.config.outputs.vnc_enabled == 'true'
        run: |
          echo "Installing Google Chrome..."
          wget -q https://dl.google.com/linux/direct/google-chrome-stable_current_amd64.deb
          sudo dpkg -i google-chrome-stable_current_amd64.deb || sudo apt-get install -f -y
          rm google-chrome-stable_current_amd64.deb
          google-chrome --version
          echo "‚úÖ Google Chrome installed"

      - name: Install TurboVNC Server
        if: steps.config.outputs.vnc_enabled == 'true'
        run: |
          echo "Installing TurboVNC server..."
          wget -q https://phoenixnap.dl.sourceforge.net/project/turbovnc/2.2.5/turbovnc_2.2.5_amd64.deb
          sudo dpkg -i turbovnc_2.2.5_amd64.deb
          rm turbovnc_2.2.5_amd64.deb

      - name: Install noVNC (Web VNC)
        if: steps.config.outputs.vnc_enabled == 'true'
        run: |
          echo "Installing noVNC for web-based access..."
          cd ~
          git clone https://github.com/novnc/noVNC.git
          cd noVNC
          git clone https://github.com/novnc/websockify.git

      - name: Configure VNC Server
        if: steps.config.outputs.vnc_enabled == 'true'
        run: |
          export PATH=$PATH:/opt/TurboVNC/bin
          mkdir -p ~/.vnc
          
          # Create password file
          echo "${{ steps.config.outputs.vnc_password }}" | vncpasswd -f > ~/.vnc/passwd
          chmod 600 ~/.vnc/passwd
          
          # Create xstartup script
          cat > ~/.vnc/xstartup.turbovnc << 'EOF'
          #!/bin/bash
          # Suppress accessibility warnings
          export NO_AT_BRIDGE=1
          export SESSION_MANAGER=""
          
          # Start XFCE desktop
          dbus-launch /usr/bin/startxfce4 &
          EOF
          
          chmod +x ~/.vnc/xstartup.turbovnc

      - name: Start VNC Server
        if: steps.config.outputs.vnc_enabled == 'true'
        run: |
          export PATH=$PATH:/opt/TurboVNC/bin
          echo "Starting TurboVNC server on display :1..."
          
          vncserver :1 -geometry 1920x1080 -depth 24 -rfbport $VNC_PORT 2>&1 | tee /tmp/vnc-start.log
          sleep 8
          
          if pgrep -f "Xvnc.*:1" > /dev/null; then
            echo "‚úÖ TurboVNC Server started successfully on port $VNC_PORT"
            ps aux | grep Xvnc | grep -v grep
          else
            echo "‚ùå Failed to start VNC server"
            cat /tmp/vnc-start.log
            exit 1
          fi

      - name: Start noVNC (Web VNC)
        if: steps.config.outputs.vnc_enabled == 'true'
        run: |
          echo "Starting noVNC web server..."
          cd ~/noVNC
          ./utils/novnc_proxy --vnc localhost:$VNC_PORT --listen $NOVNC_PORT &
          sleep 3
          
          if netstat -tuln | grep :$NOVNC_PORT > /dev/null; then
            echo "‚úÖ noVNC started successfully on port $NOVNC_PORT"
          else
            echo "‚ùå noVNC failed to start"
            exit 1
          fi

      - name: Download and Setup BotXByte Extension
        if: steps.config.outputs.vnc_enabled == 'true'
        run: |
          echo "Downloading BotXByte extension..."

          # Install python3-venv
          sudo apt-get install -y python3 python3-venv

          DOWNLOADS_DIR="$HOME/Downloads"
          EXTENSION_DIR="$DOWNLOADS_DIR/real-botxbyte-extension"
          mkdir -p "$DOWNLOADS_DIR"

          # Download the extension zip
          wget -q -O "$DOWNLOADS_DIR/real-botxbyte-extension.zip" \
            "https://github.com/user-attachments/files/25457672/real-botxbyte-extension.zip"

          # Extract to a temp location to handle nested directories
          TEMP_EXTRACT="/tmp/extension-extract"
          rm -rf "$TEMP_EXTRACT"
          mkdir -p "$TEMP_EXTRACT"
          unzip -o "$DOWNLOADS_DIR/real-botxbyte-extension.zip" -d "$TEMP_EXTRACT"
          rm "$DOWNLOADS_DIR/real-botxbyte-extension.zip"

          # Find where manifest.json actually is
          MANIFEST_PATH=$(find "$TEMP_EXTRACT" -name "manifest.json" -type f | head -1)
          if [ -z "$MANIFEST_PATH" ]; then
            echo "‚ùå manifest.json not found in extracted zip!"
            find "$TEMP_EXTRACT" -type f
            exit 1
          fi

          ACTUAL_EXT_DIR=$(dirname "$MANIFEST_PATH")
          echo "Found manifest.json at: $MANIFEST_PATH"

          # Move to the expected location
          rm -rf "$EXTENSION_DIR"
          mv "$ACTUAL_EXT_DIR" "$EXTENSION_DIR"
          rm -rf "$TEMP_EXTRACT"

          # Clean up stale/non-extension files
          rm -rf "$EXTENSION_DIR/_metadata" 2>/dev/null || true
          rm -rf "$EXTENSION_DIR/.git" 2>/dev/null || true
          rm -f "$EXTENSION_DIR/.gitignore" "$EXTENSION_DIR/.env.dev" "$EXTENSION_DIR/README.md" "$EXTENSION_DIR/llm.txt"

          echo "Extension contents:"
          ls -la "$EXTENSION_DIR/"
          echo "manifest.json:"
          cat "$EXTENSION_DIR/manifest.json"

          # Set up Python virtual environment and install requirements
          cd "$EXTENSION_DIR"
          python3 -m venv venv
          source venv/bin/activate

          if [ -f requirements.txt ]; then
            pip install -r requirements.txt
            echo "‚úÖ Requirements installed in venv"
          else
            echo "‚ö†Ô∏è No requirements.txt found"
          fi

          echo "‚úÖ BotXByte Extension setup complete"
          echo "  Extension path: $EXTENSION_DIR"

      - name: Start BotXByte Server
        if: steps.config.outputs.vnc_enabled == 'true'
        id: botxbyte_server
        run: |
          echo "Starting BotXByte server (server.py)..."

          EXTENSION_DIR="$HOME/Downloads/real-botxbyte-extension"
          cd "$EXTENSION_DIR"

          source venv/bin/activate
          export WORKSPACE_ID="${{ steps.config.outputs.workspace_id }}"

          python3 server.py &
          SERVER_PID=$!
          echo "server_pid=$SERVER_PID" >> $GITHUB_OUTPUT

          sleep 3

          if kill -0 $SERVER_PID 2>/dev/null; then
            echo "‚úÖ BotXByte server started (PID: $SERVER_PID)"
            echo "  WebSocket: ws://localhost:8765"
            echo "  HTTP API:  http://localhost:8766"
          else
            echo "‚ùå BotXByte server failed to start"
            exit 1
          fi

      - name: Setup Browser Profile
        if: steps.config.outputs.vnc_enabled == 'true'
        id: browser_profile
        env:
          AWS_ACCESS_KEY_ID: ${{ steps.config.outputs.wasabi_access_key }}
          AWS_SECRET_ACCESS_KEY: ${{ steps.config.outputs.wasabi_secret_key }}
          AWS_DEFAULT_REGION: ${{ steps.config.outputs.wasabi_region }}
        run: |
          BROWSER_PROFILE_ID="${{ steps.config.outputs.browser_profile_id }}"
          WASABI_BUCKET="${{ steps.config.outputs.wasabi_bucket }}"
          WASABI_ENDPOINT="${{ steps.config.outputs.wasabi_endpoint }}"
          PROFILE_DIR="$HOME/browser-profiles/${BROWSER_PROFILE_ID}"
          WASABI_KEY="browser-profiles/${BROWSER_PROFILE_ID}.zip"

          echo "browser_profile_dir=$PROFILE_DIR" >> $GITHUB_OUTPUT

          mkdir -p "$HOME/browser-profiles"

          PROFILE_EXISTS="false"

          # Check if browser profile exists in Wasabi
          if [ -n "$WASABI_BUCKET" ] && [ "$WASABI_BUCKET" != "" ] && [ -n "$BROWSER_PROFILE_ID" ] && [ "$BROWSER_PROFILE_ID" != "" ]; then
            echo "Checking Wasabi for existing browser profile: $WASABI_KEY"

            if aws s3 ls "s3://${WASABI_BUCKET}/${WASABI_KEY}" --endpoint-url "$WASABI_ENDPOINT" 2>/dev/null; then
              echo "‚úÖ Browser profile found in Wasabi! Downloading..."
              PROFILE_EXISTS="true"

              # Download the zip
              aws s3 cp "s3://${WASABI_BUCKET}/${WASABI_KEY}" "/tmp/${BROWSER_PROFILE_ID}.zip" \
                --endpoint-url "$WASABI_ENDPOINT"

              echo "Extracting browser profile..."
              unzip -o "/tmp/${BROWSER_PROFILE_ID}.zip" -d "$HOME/browser-profiles/"
              rm -f "/tmp/${BROWSER_PROFILE_ID}.zip"

              if [ -d "$PROFILE_DIR" ]; then
                echo "‚úÖ Browser profile extracted to: $PROFILE_DIR"
                echo "  Profile size: $(du -sh "$PROFILE_DIR" | cut -f1)"
              else
                echo "‚ö†Ô∏è Extraction did not produce expected directory, creating fresh profile"
                PROFILE_EXISTS="false"
              fi
            else
              echo "No existing browser profile found in Wasabi"
            fi
          else
            echo "‚ö†Ô∏è Wasabi not configured or no browser_profile_id, using fresh profile"
          fi

          # If no profile exists, create a fresh one
          if [ "$PROFILE_EXISTS" = "false" ]; then
            echo "Creating fresh browser profile: $PROFILE_DIR"
            mkdir -p "$PROFILE_DIR"
            echo "‚úÖ Fresh browser profile directory created"
          fi

          echo "profile_exists=$PROFILE_EXISTS" >> $GITHUB_OUTPUT
          echo "Browser Profile ID: $BROWSER_PROFILE_ID"
          echo "Profile Directory: $PROFILE_DIR"

      - name: Open Chrome on Desktop
        if: steps.config.outputs.vnc_enabled == 'true'
        run: |
          echo "Opening Chrome on VNC desktop with browser profile..."

          PROFILE_DIR="${{ steps.browser_profile.outputs.browser_profile_dir }}"
          echo "Using profile directory: $PROFILE_DIR"

          export DISPLAY=:1
          export NO_AT_BRIDGE=1
          export DBUS_SESSION_BUS_ADDRESS=/dev/null

          google-chrome \
            --no-first-run \
            --no-default-browser-check \
            --disable-gpu \
            --no-sandbox \
            --disable-dev-shm-usage \
            --user-data-dir="$PROFILE_DIR" \
            2>/tmp/chrome-stderr.log &

          CHROME_PID=$!
          echo "  Chrome PID: $CHROME_PID"
          sleep 5

          if pgrep -f "chrome" > /dev/null; then
            echo "‚úÖ Chrome is running with persistent profile"
          else
            echo "‚ùå Chrome failed to launch"
            tail -20 /tmp/chrome-stderr.log 2>/dev/null || true
            exit 1
          fi

      - name: Install cloudflared
        if: steps.config.outputs.cloudflare_enabled == 'true'
        run: |
          echo "Installing cloudflared..."
          wget -q https://github.com/cloudflare/cloudflared/releases/latest/download/cloudflared-linux-amd64.deb
          sudo dpkg -i cloudflared-linux-amd64.deb
          cloudflared --version

      - name: Create Cloudflare Tunnel
        if: steps.config.outputs.cloudflare_enabled == 'true'
        id: tunnel
        run: |
          echo "Creating Cloudflare Tunnel..."
          
          RESPONSE=$(curl -s -A "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36" \
            "https://api.cloudflare.com/client/v4/accounts/${{ steps.config.outputs.cloudflare_account_id }}/cfd_tunnel" \
            --request POST \
            --header "Authorization: Bearer ${{ steps.config.outputs.cloudflare_api_token }}" \
            --header "Content-Type: application/json" \
            --data '{
              "name": "github-vnc-'$(date +%s)'",
              "config_src": "cloudflare"
            }')
          
          # Check if tunnel creation was successful
          SUCCESS=$(echo "$RESPONSE" | jq -r '.success // false')
          if [ "$SUCCESS" != "true" ]; then
            echo "‚ùå Failed to create tunnel"
            echo "$RESPONSE" | jq '.'
            exit 1
          fi
          
          TUNNEL_ID=$(echo "$RESPONSE" | jq -r '.result.id')
          TUNNEL_TOKEN=$(echo "$RESPONSE" | jq -r '.result.token')
          
          if [ -z "$TUNNEL_ID" ] || [ "$TUNNEL_ID" = "null" ]; then
            echo "‚ùå Failed to extract tunnel ID"
            exit 1
          fi
          
          echo "tunnel_id=$TUNNEL_ID" >> $GITHUB_OUTPUT
          echo "tunnel_token=$TUNNEL_TOKEN" >> $GITHUB_OUTPUT
          echo "‚úÖ Tunnel created: $TUNNEL_ID"

      - name: Configure Tunnel
        if: steps.config.outputs.cloudflare_enabled == 'true'
        run: |
          echo "Configuring tunnel for noVNC..."
          
          RESPONSE=$(curl -s -A "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36" \
            "https://api.cloudflare.com/client/v4/accounts/${{ steps.config.outputs.cloudflare_account_id }}/cfd_tunnel/${{ steps.tunnel.outputs.tunnel_id }}/configurations" \
            --request PUT \
            --header "Authorization: Bearer ${{ steps.config.outputs.cloudflare_api_token }}" \
            --header "Content-Type: application/json" \
            --data "{
              \"config\": {
                \"ingress\": [
                  {
                    \"hostname\": \"${{ steps.config.outputs.hostname }}\",
                    \"path\": \"/vnc/*\",
                    \"service\": \"http://localhost:${NOVNC_PORT}\",
                    \"originRequest\": {}
                  },
                  {
                    \"hostname\": \"${{ steps.config.outputs.hostname }}\",
                    \"path\": \"/browser-agent-management-service/*\",
                    \"service\": \"http://localhost:8766\",
                    \"originRequest\": {}
                  },
                  {
                    \"hostname\": \"${{ steps.config.outputs.hostname }}\",
                    \"service\": \"http://localhost:${NOVNC_PORT}\",
                    \"originRequest\": {}
                  },
                  {
                    \"service\": \"http_status:404\"
                  }
                ]
              }
            }")
          
          SUCCESS=$(echo "$RESPONSE" | jq -r '.success')
          if [ "$SUCCESS" != "true" ]; then
            echo "‚ùå Failed to configure tunnel"
            echo "$RESPONSE" | jq '.'
            exit 1
          fi
          
          echo "‚úÖ Tunnel configured"

      - name: Create DNS Record
        if: steps.config.outputs.cloudflare_enabled == 'true'
        run: |
          echo "Creating DNS record..."
          
          FULL_HOSTNAME="${{ steps.config.outputs.hostname }}"
          echo "Hostname: $FULL_HOSTNAME"
          echo "Tunnel ID: ${{ steps.tunnel.outputs.tunnel_id }}"
          echo "Target: ${{ steps.tunnel.outputs.tunnel_id }}.cfargotunnel.com"
          
          # Check for existing DNS record
          EXISTING_RESPONSE=$(curl -s -A "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36" \
            "https://api.cloudflare.com/client/v4/zones/${{ steps.config.outputs.cloudflare_zone_id }}/dns_records?name=${FULL_HOSTNAME}" \
            --header "Authorization: Bearer ${{ steps.config.outputs.cloudflare_api_token }}")
          
          echo "Existing DNS check response:"
          echo "$EXISTING_RESPONSE" | jq '.'
          
          EXISTING=$(echo "$EXISTING_RESPONSE" | jq -r '.result[0].id // empty')
          
          if [ -n "$EXISTING" ]; then
            echo "‚ö†Ô∏è DNS record already exists (ID: $EXISTING), deleting..."
            DELETE_RESPONSE=$(curl -s -A "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36" \
              "https://api.cloudflare.com/client/v4/zones/${{ steps.config.outputs.cloudflare_zone_id }}/dns_records/${EXISTING}" \
              --request DELETE \
              --header "Authorization: Bearer ${{ steps.config.outputs.cloudflare_api_token }}")
            echo "Delete response:"
            echo "$DELETE_RESPONSE" | jq '.'
            sleep 2
          fi
          
          # Create new DNS record
          echo "Creating new DNS record..."
          RESPONSE=$(curl -s -A "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36" \
            "https://api.cloudflare.com/client/v4/zones/${{ steps.config.outputs.cloudflare_zone_id }}/dns_records" \
            --request POST \
            --header "Authorization: Bearer ${{ steps.config.outputs.cloudflare_api_token }}" \
            --header "Content-Type: application/json" \
            --data "{
              \"type\": \"CNAME\",
              \"proxied\": true,
              \"name\": \"${FULL_HOSTNAME}\",
              \"content\": \"${{ steps.tunnel.outputs.tunnel_id }}.cfargotunnel.com\"
            }")
          
          echo "Create DNS response:"
          echo "$RESPONSE" | jq '.'
          
          SUCCESS=$(echo "$RESPONSE" | jq -r '.success')
          if [ "$SUCCESS" != "true" ]; then
            echo "‚ùå Failed to create DNS record"
            echo "Error details:"
            echo "$RESPONSE" | jq '.errors'
            exit 1
          fi
          
          DNS_RECORD_ID=$(echo "$RESPONSE" | jq -r '.result.id')
          echo "‚úÖ DNS record created successfully (ID: $DNS_RECORD_ID)"

      - name: Start Cloudflare Tunnel
        if: steps.config.outputs.cloudflare_enabled == 'true'
        run: |
          echo "Starting Cloudflare Tunnel..."
          cloudflared tunnel run --token ${{ steps.tunnel.outputs.tunnel_token }} > /tmp/tunnel.log 2>&1 &
          sleep 10
          
          if ! pgrep -x "cloudflared" > /dev/null; then
            echo "‚ùå Cloudflare tunnel failed to start"
            cat /tmp/tunnel.log
            exit 1
          fi
          
          echo "‚úÖ Cloudflare Tunnel started"

      - name: Register Tunnel URL with Backend
        if: steps.config.outputs.cloudflare_enabled == 'true'
        run: |
          echo "Registering tunnel URL with backend..."

          FULL_HOSTNAME="${{ steps.config.outputs.hostname }}"
          TUNNEL_URL="https://${FULL_HOSTNAME}"
          USER_ID="${{ steps.config.outputs.user_id }}"
          WORKSPACE_ID="${{ steps.config.outputs.workspace_id }}"
          BROWSER_PROFILE_ID="${{ steps.config.outputs.browser_profile_id }}"
          CLOUDFLARE_TUNNEL_CREDENTIAL_ID="${{ steps.config.outputs.cloudflare_tunnel_credential_id }}"

          # Build JSON body - include cloudflare_tunnel_credential_id only if present
          if [ -n "$CLOUDFLARE_TUNNEL_CREDENTIAL_ID" ] && [ "$CLOUDFLARE_TUNNEL_CREDENTIAL_ID" != "null" ]; then
            BODY="{
              \"tunnel_url\": \"${TUNNEL_URL}\",
              \"browser_profile_id\": \"${BROWSER_PROFILE_ID}\",
              \"cloudflare_tunnel_credential_id\": \"${CLOUDFLARE_TUNNEL_CREDENTIAL_ID}\",
              \"status\": \"created\",
              \"is_active\": true
            }"
          else
            BODY="{
              \"tunnel_url\": \"${TUNNEL_URL}\",
              \"browser_profile_id\": \"${BROWSER_PROFILE_ID}\",
              \"status\": \"created\",
              \"is_active\": true
            }"
          fi

          echo "Request body: $BODY"

          RESPONSE=$(curl -s "http://129.212.196.173/ai-management-service/api/v1/cloudflare-tunnel-info/create/" \
            -X POST \
            -H "Content-Type: application/json" \
            -H "user-id: ${USER_ID}" \
            -H "workspace-id: ${WORKSPACE_ID}" \
            -d "$BODY")

          SUCCESS=$(echo "$RESPONSE" | jq -r '.success // false')
          if [ "$SUCCESS" = "true" ]; then
            echo "‚úÖ Tunnel URL registered: ${TUNNEL_URL}"
          else
            echo "‚ö†Ô∏è Failed to register tunnel URL (non-fatal)"
            echo "$RESPONSE" | jq '.' 2>/dev/null || echo "$RESPONSE"
          fi

      - name: Display VNC Connection Info
        if: steps.config.outputs.cloudflare_enabled == 'true'
        run: |
          echo ""
          echo "‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó"
          echo "‚ïë          üéâ UBUNTU DESKTOP VNC IS NOW RUNNING! üéâ            ‚ïë"
          echo "‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù"
          echo ""
          echo "üåê Access URL: https://${{ steps.config.outputs.hostname }}/vnc.html"
          echo "üîë Password: (configured)"
          echo ""
          echo "üîå BotXByte server.py running"
          echo "   WebSocket: ws://localhost:8765"
          echo "   HTTP API:  http://localhost:8766"
          echo ""
          echo "üì¶ Extension ready at: ~/Downloads/real-botxbyte-extension"
          echo "   Load it manually: Chrome > Extensions > Developer Mode > Load Unpacked"
          echo ""
          
      - name: Keep VNC Session Alive
        if: steps.config.outputs.vnc_enabled == 'true'
        run: |
          export PATH=$PATH:/opt/TurboVNC/bin
          export DBUS_SESSION_BUS_ADDRESS=/dev/null

          echo "Keeping VNC session alive..."

          # Monitor for 45 mins (2700 seconds)
          END_TIME=$((SECONDS + 2700))

          while [ $SECONDS -lt $END_TIME ]; do
            REMAINING=$((END_TIME - SECONDS))
            HOURS=$((REMAINING / 3600))
            MINUTES=$(((REMAINING % 3600) / 60))

            if [ "${{ steps.config.outputs.cloudflare_enabled }}" = "true" ]; then
              echo "‚è±Ô∏è Remaining: ${HOURS}h ${MINUTES}m | Access: https://${{ steps.config.outputs.hostname }}/vnc.html"
            else
              echo "‚è±Ô∏è Remaining: ${HOURS}h ${MINUTES}m | VNC running locally"
            fi

            # Check and restart VNC if needed
            if ! pgrep -f "Xvnc.*:1" > /dev/null; then
              echo "‚ùå VNC stopped! Restarting..."
              vncserver :1 -geometry 1920x1080 -depth 24 -rfbport $VNC_PORT
              sleep 3
              if ! pgrep -f "Xvnc.*:1" > /dev/null; then
                echo "‚ùå Failed to restart VNC! Exiting..."
                exit 1
              fi
              echo "‚úÖ VNC restarted successfully"
            fi

            # Check and restart tunnel if Cloudflare is enabled
            if [ "${{ steps.config.outputs.cloudflare_enabled }}" = "true" ]; then
              if ! pgrep -x "cloudflared" > /dev/null; then
                echo "‚ùå Tunnel stopped! Restarting..."
                cloudflared tunnel run --token ${{ steps.tunnel.outputs.tunnel_token }} > /tmp/tunnel.log 2>&1 &
                sleep 5
                if ! pgrep -x "cloudflared" > /dev/null; then
                  echo "‚ùå Failed to restart tunnel! Exiting..."
                  cat /tmp/tunnel.log
                  exit 1
                fi
                echo "‚úÖ Tunnel restarted successfully"
              fi
            fi

            # Check and restart BotXByte server if needed
            if ! pgrep -f "server.py" > /dev/null; then
              echo "‚ùå BotXByte server stopped! Restarting..."
              EXTENSION_DIR="$HOME/Downloads/real-botxbyte-extension"
              cd "$EXTENSION_DIR"
              source venv/bin/activate
              export WORKSPACE_ID="${{ steps.config.outputs.workspace_id }}"
              python3 server.py &
              sleep 3
              if pgrep -f "server.py" > /dev/null; then
                echo "‚úÖ BotXByte server restarted"
              else
                echo "‚ö†Ô∏è BotXByte server failed to restart"
              fi
            fi

            # Check and restart Chrome if needed
            if ! pgrep -f "google-chrome" > /dev/null; then
              echo "‚ùå Chrome stopped! Restarting..."
              export DISPLAY=:1
              export NO_AT_BRIDGE=1
              PROFILE_DIR="${{ steps.browser_profile.outputs.browser_profile_dir }}"
              google-chrome \
                --no-first-run \
                --no-default-browser-check \
                --disable-gpu \
                --no-sandbox \
                --disable-dev-shm-usage \
                --user-data-dir="$PROFILE_DIR" \
                2>/tmp/chrome-stderr.log &
              sleep 5
              if pgrep -f "google-chrome" > /dev/null; then
                echo "‚úÖ Chrome restarted"
              else
                echo "‚ö†Ô∏è Chrome failed to restart"
              fi
            fi

            sleep 30
          done

          echo "‚úÖ Session time expired"

      - name: Cleanup BotXByte Server and Chrome
        if: always() && steps.config.outputs.vnc_enabled == 'true'
        run: |
          echo "Cleaning up BotXByte server and Chrome..."

          # Kill Chrome
          pkill -f "google-chrome" || true

          # Kill server.py
          pkill -f "server.py" || true

          sleep 2
          echo "‚úÖ BotXByte cleanup complete"

      - name: Upload Browser Profile to Wasabi
        if: always() && steps.config.outputs.vnc_enabled == 'true' && steps.config.outputs.wasabi_access_key != ''
        env:
          AWS_ACCESS_KEY_ID: ${{ steps.config.outputs.wasabi_access_key }}
          AWS_SECRET_ACCESS_KEY: ${{ steps.config.outputs.wasabi_secret_key }}
          AWS_DEFAULT_REGION: ${{ steps.config.outputs.wasabi_region }}
        run: |
          echo "Uploading browser profile to Wasabi..."

          BROWSER_PROFILE_ID="${{ steps.config.outputs.browser_profile_id }}"
          WASABI_BUCKET="${{ steps.config.outputs.wasabi_bucket }}"
          WASABI_ENDPOINT="${{ steps.config.outputs.wasabi_endpoint }}"
          PROFILE_DIR="$HOME/browser-profiles/${BROWSER_PROFILE_ID}"
          WASABI_KEY="browser-profiles/${BROWSER_PROFILE_ID}.zip"

          # Debug: verify credentials are available
          echo "  AWS_ACCESS_KEY_ID set: $([ -n "$AWS_ACCESS_KEY_ID" ] && echo 'yes' || echo 'no')"
          echo "  AWS_DEFAULT_REGION: $AWS_DEFAULT_REGION"
          echo "  Wasabi Endpoint: $WASABI_ENDPOINT"
          echo "  Wasabi Bucket: $WASABI_BUCKET"
          echo "  Browser Profile ID: $BROWSER_PROFILE_ID"

          if [ -z "$BROWSER_PROFILE_ID" ] || [ "$BROWSER_PROFILE_ID" = "" ]; then
            echo "‚ö†Ô∏è No browser_profile_id, skipping upload"
            exit 0
          fi

          if [ ! -d "$PROFILE_DIR" ]; then
            echo "‚ö†Ô∏è Browser profile directory not found: $PROFILE_DIR, skipping upload"
            ls -la "$HOME/browser-profiles/" 2>/dev/null || echo "  browser-profiles dir does not exist"
            exit 0
          fi

          echo "Zipping browser profile: $PROFILE_DIR"
          echo "  Profile size before zip: $(du -sh "$PROFILE_DIR" | cut -f1)"

          cd "$HOME/browser-profiles"
          zip -r "/tmp/${BROWSER_PROFILE_ID}.zip" "${BROWSER_PROFILE_ID}/" -x "*/SingletonLock" "*/SingletonCookie" "*/SingletonSocket"

          ZIP_SIZE=$(du -sh "/tmp/${BROWSER_PROFILE_ID}.zip" | cut -f1)
          echo "  Zip size: $ZIP_SIZE"

          echo "Uploading to Wasabi: s3://${WASABI_BUCKET}/${WASABI_KEY}"
          aws s3 cp "/tmp/${BROWSER_PROFILE_ID}.zip" "s3://${WASABI_BUCKET}/${WASABI_KEY}" \
            --endpoint-url "$WASABI_ENDPOINT"

          echo "‚úÖ Browser profile uploaded to Wasabi successfully"
          echo "  Bucket: $WASABI_BUCKET"
          echo "  Key: $WASABI_KEY"
          echo "  Size: $ZIP_SIZE"

          rm -f "/tmp/${BROWSER_PROFILE_ID}.zip"

      - name: Cleanup Webshare IP Authorization
        if: always() && steps.config.outputs.webshare_enabled == 'true'
        run: |
          echo "Deregistering IP from Webshare..."
          
          if [ -n "${{ steps.webshare.outputs.webshare_auth_id }}" ] && [ "${{ steps.webshare.outputs.webshare_auth_id }}" != "null" ]; then
            DELETE_RESPONSE=$(curl -s "https://proxy.webshare.io/api/v2/proxy/ipauthorization/${{ steps.webshare.outputs.webshare_auth_id }}/" \
              -X DELETE \
              -H "Authorization: Token ${{ steps.config.outputs.webshare_api_token }}")
            
            # Check if deletion was successful (empty response or 204 status)
            if [ -z "$DELETE_RESPONSE" ] || [ "$DELETE_RESPONSE" = "{}" ]; then
              echo "‚úÖ IP authorization removed from Webshare"
            else
              echo "‚ö†Ô∏è Failed to remove IP authorization"
              echo "$DELETE_RESPONSE"
            fi
          else
            echo "‚ö†Ô∏è No Webshare authorization ID found to delete"
          fi
          
          echo "‚úÖ Webshare cleanup complete"

      - name: Cleanup Cloudflare Tunnel and DNS
        if: always() && steps.config.outputs.cloudflare_enabled == 'true'
        run: |
          echo "Cleaning up Cloudflare tunnel and DNS record..."
          
          # Stop cloudflared process
          pkill -x cloudflared || true
          sleep 2
          
          # Delete tunnel info from AI Management Service
          FULL_HOSTNAME="${{ steps.config.outputs.hostname }}"
          if [ -n "$FULL_HOSTNAME" ] && [ "$FULL_HOSTNAME" != "null" ]; then
            echo "Deleting tunnel info from AI Management Service..."
            
            USER_ID="${{ steps.config.outputs.user_id }}"
            WORKSPACE_ID="${{ steps.config.outputs.workspace_id }}"
            BROWSER_PROFILE_ID="${{ steps.config.outputs.browser_profile_id }}"
            
            # Build URL with parameters
            DELETE_URL="http://129.212.196.173/ai-management-service/api/v1/cloudflare-tunnel-info/delete/?tunnel_url=https://${FULL_HOSTNAME}"
            
            # Add browser_profile_id if it exists
            if [ -n "$BROWSER_PROFILE_ID" ] && [ "$BROWSER_PROFILE_ID" != "null" ]; then
              DELETE_URL="${DELETE_URL}&browser_profile_id=${BROWSER_PROFILE_ID}"
            fi
            
            DELETE_TUNNEL_INFO=$(curl -s "$DELETE_URL" \
              -X DELETE \
              -H "user-id: ${USER_ID}" \
              -H "workspace-id: ${WORKSPACE_ID}")
            
            echo "Tunnel info deletion response:"
            echo "$DELETE_TUNNEL_INFO"
          fi
          
          # Delete DNS record
          if [ -n "$FULL_HOSTNAME" ] && [ "$FULL_HOSTNAME" != "null" ]; then
            echo "Deleting DNS record for ${FULL_HOSTNAME}..."
            EXISTING_DNS=$(curl -s -A "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36" \
              "https://api.cloudflare.com/client/v4/zones/${{ steps.config.outputs.cloudflare_zone_id }}/dns_records?name=${FULL_HOSTNAME}" \
              --header "Authorization: Bearer ${{ steps.config.outputs.cloudflare_api_token }}" | jq -r '.result[0].id // empty')
            
            if [ -n "$EXISTING_DNS" ]; then
              DELETE_RESPONSE=$(curl -s -A "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36" \
                "https://api.cloudflare.com/client/v4/zones/${{ steps.config.outputs.cloudflare_zone_id }}/dns_records/${EXISTING_DNS}" \
                --request DELETE \
                --header "Authorization: Bearer ${{ steps.config.outputs.cloudflare_api_token }}")
              
              DELETE_SUCCESS=$(echo "$DELETE_RESPONSE" | jq -r '.success // false')
              if [ "$DELETE_SUCCESS" = "true" ]; then
                echo "‚úÖ DNS record deleted successfully"
              else
                echo "‚ö†Ô∏è Failed to delete DNS record"
                echo "$DELETE_RESPONSE" | jq '.'
              fi
            else
              echo "‚ö†Ô∏è DNS record not found"
            fi
          fi
          
          # Delete Cloudflare tunnel
          if [ -n "${{ steps.tunnel.outputs.tunnel_id }}" ] && [ "${{ steps.tunnel.outputs.tunnel_id }}" != "null" ]; then
            echo "Deleting Cloudflare tunnel ${{ steps.tunnel.outputs.tunnel_id }}..."
            TUNNEL_DELETE_RESPONSE=$(curl -s -A "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36" \
              "https://api.cloudflare.com/client/v4/accounts/${{ steps.config.outputs.cloudflare_account_id }}/cfd_tunnel/${{ steps.tunnel.outputs.tunnel_id }}" \
              --request DELETE \
              --header "Authorization: Bearer ${{ steps.config.outputs.cloudflare_api_token }}")
            
            TUNNEL_DELETE_SUCCESS=$(echo "$TUNNEL_DELETE_RESPONSE" | jq -r '.success // false')
            if [ "$TUNNEL_DELETE_SUCCESS" = "true" ]; then
              echo "‚úÖ Cloudflare tunnel deleted successfully"
            else
              echo "‚ö†Ô∏è Failed to delete Cloudflare tunnel"
              echo "$TUNNEL_DELETE_RESPONSE" | jq '.'
            fi
          else
            echo "‚ö†Ô∏è Tunnel ID not found"
          fi
          
          echo "‚úÖ Cloudflare cleanup complete"

      - name: Cleanup VNC
        if: always() && steps.config.outputs.vnc_enabled == 'true'
        run: |
          export PATH=$PATH:/opt/TurboVNC/bin
          echo "Cleaning up VNC server..."
          
          vncserver -kill :1 || true
          
          echo "‚úÖ VNC cleanup complete"
